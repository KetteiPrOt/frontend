<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Parte 12</title>
	<link rel="icon" href="../../../../media/book.ico">
	<link rel="stylesheet" href="../../styles.css">
</head>
<body>
	<h1 class="titulo-principal">Objetos (Diccionarios)</h1>
	<h4 class="enlace-volver"><a href="../capitulo2.html">Volver al capitulo</a></h4>
	<hr>

	<!-- Definicion -->
	<h3>Definicion</h3>
	<p>Un Objeto en JavaScript es un diccionario que tiene propiedades o pares clave-valor. Cada propiedad tiene un nombre llamado 'clave' y cada clave corresponde a su 'valor' dentro del objeto.</p>
	<code>
		const objeto = { <br>
		&nbsp &nbsp propiedad1: valor1, <br>
	    &nbsp &nbsp propiedad2: valor2, <br>
	    &nbsp &nbsp propiedad3: valor3, <br>
	    &nbsp &nbsp ... <br>
	    &nbsp &nbsp propiedadN: valorN <br>
	    }
	</code>
	<p>
		El valor puede ser un dato de cualquier tipo, una varible, un array, e incluso otros objetos. <br>
		La llave puede ser una cadena de texto que debe ir entre comillas si tiene espacios, un simbolo, o un numero.
	</p>

	<!-- Sintaxis y usos -->
	<h3>Sintaxis y usos</h3>
	<p>Para llamar un valor contenido dentro del objeto debemos pasarle, entre comillas, la llave que le corresponde a ese valor.</p>
	<code>
		alert(objeto['propiedad1']); // valor1 <br>
		alert(objeto['propiedad2']); // valor2 <br>
	</code>

	<!-- Agregar un nuevo valor con su llave -->
	<h3>Agregar un nuevo valor con su llave</h3>
	<p>Podemos agregar un nuevo valor con su llave al objeto utilizando con dos sintaxis. La primera es:</p>
	<code>
		const objeto = {}; <br>
		objeto.llaveNueva = valorNuevo; <br>
		alert(objeto); // { llaveNueva: valorNuevo }
	</code>

	<p>La segunda es util cuando queremos agregar una llave que tenga espacios:</p>
	<code>
		const objeto = {}; <br>
		objeto.['llave nueva'] = valorNuevo; <br>
		alert(objeto); // { 'llave nueva': valorNuevo }
	</code>

	<!-- Agregar metodos a un objeto -->
	<h3>Agregar metodos a un objeto</h3>
	<p>Podemos agregar un Metodo a un objeto utilizando la siguiente notacion</p>
	<code>
		const objeto = { <br>
		&nbsp &nbsp nombreMetodo () { ... } <br>
	    }
	</code>

	<p>Luego para invocarlo debe ser de la siguiente forma:</p>
	<code>
		objeto.nombreMetodo();
	</code>
	<p>Invocar el metodo ejecutara todo el codigo que este contenga.</p>

	<!-- Funcion keys() -->
	<h3>Funcion keys()</h3>
	<p>Esta funcion nos retorna un arreglo que contiene todas las llaves de un objeto que le pasemos de la siguiente manera:</p>
	<code>
		let llaves = Object.keys(miObjeto); <br>
		alert(llaves); // [llave1, llave2, ... , llaveN]
	</code>

	<!-- Funcion values() -->
	<h3>Funcion values()</h3>
	<p>Esta funcion nos retorna un arreglo que contiene todos los valores de un objeto que le pasemos de la siguiente manera:</p>
	<code>
		let valores = Object.values(miObjeto); <br>
		alert(valores); // [valor1, valor2, ... , valorN]
	</code>

	<!-- delete -->
	<h3>delete</h3>
	<p>Se puede eliminar una propiedad (una llave y un valor) de un objeto con la siguiente orden:</p>
	<code>delete miObjeto.llave;</code>
	<p>Esto eliminara del objeto la llave indicada junto a su valor asociado.</p>

	<!-- Destructuracion -->
	<h3>Destructuracion</h3>
	<p>
		Proporciona una forma conveniente y eficiente de desempaquetar valores de objetos, lo que facilita el trabajo con datos de manera estructurada.
	</p>
	<p>
		Aqui no invocamos el valor de una propiedad del objeto con un punto... sino que obtenemos la propiedad entera como una nueva variable. El objeto no sufre modificacion alguna al hacer esto.
	</p>
	<!-- codigo -->
	<code>
		const objeto = { <br>&nbsp&nbsp&nbsp
			propiedad1: 'valor1',<br>&nbsp&nbsp&nbsp
			propiedad2: 'valor2',<br>&nbsp&nbsp&nbsp
			propiedad3: 'valor3',<br>&nbsp&nbsp&nbsp
			propiedad4: 'valor4'<br>
		} <br><br>

		<strong>let { propiedad1 } = objeto;</strong> <br><br>

		console.log(<strong>propiedad1</strong>); // valor1 <br><br>

		console.log(objeto.propiedad1); // valor1
	</code>

	<!-- Destructuracion de valores anidados -->
	<h3>Destructuracion de valores anidados</h3>
	<p>Esta tecnica tambien funciona con valores anidados:</p>
	<!-- codigo -->
	<code>
		const objeto = {<br>&nbsp&nbsp&nbsp
			nombre: 'Joel',<br>&nbsp&nbsp&nbsp
			oficio: 'Programador',<br>&nbsp&nbsp&nbsp
			perfil: { rol: 'frontend',  lenguaje: 'JavaScript', experiencia: '6 meses' } <br>
		} <br><br>

		let { <strong>nombre</strong>, <strong>oficio</strong>, perfil: { <strong>rol</strong> }, perfil: { <strong>lenguaje</strong> }, perfil: { <strong>experiencia</strong> } }  = objeto; <br><br>

		let informacion = <br>
		`Soy ${<strong>nombre</strong>}, trabajo como ${<strong>oficio</strong>} ${<strong>rol</strong>} en ${<strong>lenguaje</strong>}. Tengo ${<strong>experiencia</strong>} de experiencia.`; <br><br>

		console.log(informacion);
		<strong>// Soy Joel, trabajo como Programador frontend en JavaScript. Tengo 6 meses de experiencia.</strong>
	</code>


	<!-- Identidad de Objetos -->
	<h3>Identidad de Objetos</h3>
	<p>Cuando creamos un objeto A y luego lo asignamos como valor de la constante B, lo que estamos haciendo es decir que la constante B va a hacer referencia al mismo espacio en la memoria que esta haciendo referencia la constante A.</p>
	<p>
		Por eso cuando preguntamos con el operador de identidad si A es igual que B dice verdadero, ya que ambos estan haciendo referencia al mismmo espacio en la memoria.
	</p>
	<!-- codigo -->
	<code>
		const A = { propiedad: 'valor' }; <br><br>

		const B = A;<br><br>

		console.log(B === A); <strong>// true</strong>
	</code>

	<p>
		Pero si creamos un nuevo objeto C con el mismo valor y preguntamos si tienen la misma identidad va adecir que es falso, porque B y C estan haciendo referencia a espacios diferentes en la memoria.
	</p>
	<!-- codigo -->
	<code>
		const C = { propiedad: 'valor' }; <br><br>

		console.log(B === C); <strong>// false</strong>
	</code>


	<!-- Operador Spread -->
	<h3>Operador Spread</h3>
	<p>
		Que ocurre si queremos tener una copia (B) de un objeto A con una identidad totalmente nueva (un nuevo espacio en la memoria), de modo que si modificamos el objeto B mas adelante no le ocurra nada al objeto A...
	</p>
	<p>
		Para obtener esta copia con identidad totalmente separada usamos el operador de Propagacion (Spread):
	</p>
	<!-- codigo -->
	<code>
		const A = { propiedad: 'valor' }; <br><br>

		const B = { ...A };<br><br>

		console.log(B); <strong>// { propiedad: 'valor' }</strong> <br><br>

		console.log(B === A); <strong>// false</strong>
	</code>


	<!-- defineProperty() -->
	<h3>defineProperty()</h3>
	<p>Este metodo estatico de la clase <em>Object</em> permite definir propiedades de solo lectura a los objetos.</p>
	<!-- codigo -->
	<code>
		const objeto = {}; <br><br>

		Object.defineProperty(objeto, 'propiedad', { value: 'valor', writeable: false }); <br><br>

		console.log(objeto); <strong>// { propiedad: valor }</strong> <br><br>

		objeto.propiedad = 'DINOSAURIO'; <br><br>

		console.log(objeto); <strong>// { propiedad: valor }</strong>
	</code>
	<p>Nota: en el modo estricto (Capitulo 11) intentar escribir en una propiedad de solo lecturalanzara un error.</p>
	<p>
		Aparentemente con esta propiedad es posible encapsular los datos de un objeto...
	</p>


	<!-- preventExtensions() -->
	<h3>preventExtensions()</h3>
	<p>Este metodo estatico de la clase <em>Object</em> sirve para hacer que un objeto ya no sea modificable (extendible).</p>
	<!-- codigo -->
	<code>
		const objeto = {}; <br><br>

		Object.preventExtensions(objeto); <br><br>

		objeto.propiedad = 'DINOSAURIO'; <br><br>

		console.log(objeto); <strong>// {}</strong>
	</code>
	<p>Nota: en el modo estricto (Capitulo 11) intentar extender el objeto en esta situacion lanzaria un error.</p>


	<!-- Encadenamiento Opcional -->
	<h3>Encadenamiento Opcional</h3>
	<p>
		El operador de encadenamiento opcional proporciona una forma de simplificar el acceso a los valores a través de objetos conectados cuando es posible que una referencia o función sea undefined o null
	</p>
	<p>
		Puede usar el encadenamiento opcional cuando intente llamar a un método que puede no existir. Esto puede ser útil, por ejemplo, cuando se usa una API en la que un método podría no estar disponible, ya sea debido a la antigüedad de la implementación o debido a una característica que no está disponible en el dispositivo del usuario.
	</p>
	<p>
		El uso de encadenamiento opcional con llamadas a funciones hace que la expresión regrese automáticamente undefined en lugar de lanzar una excepción si no se encuentra el método.
	</p>
	<!-- codigo -->
	<code>
		const objeto = { persona1: { nombre: "Joel", apellido: "Mero" } }; <br><br>

		let apellido = objeto?.persona1.apellido; <br><br>

		console.log(apellido); <strong>// Mero</strong>
	</code>


	
</body>
</html>